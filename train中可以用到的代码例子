import torch
from torch.autograd import Variable
import time
import os
import sys

from utils import AverageMeter, calculate_accuracy

def train_epoch(epoch, data_loader, model, criterion, optimizer, opt,
                epoch_logger, batch_logger,step_scheduler,val_scheduler):
    for
    
    
    y = model(x) #y为长度为3的list,
    #将target划分成不同类别的target的集合
    #即[[1,0,1],[1,1,0]]划分成[[1],[1]]和[[0],[1]] [[1],[0]]
    target_list=target.chunk(target.size()[1],dim=1)
    loss0 = criterion(y[0],target_list[0])
    loss1 = criterion(y[1],target_list[1])
    loss2 = criterion(y[2],target_list[2])
    loss = loss0+loss1+loss2
    loss.backward()
    
    
#生成样本可以用到的代码：
一个渐变用[s,e]表示，然后取样s,e,mid=(s+e)/2 ,然后再随机抽取m个中间帧
from numpy import random
    frame_no = []
    prob = []
    for x in range(s,e+1):
        frame_no.append(x)
        prob.append(0)
    gradual_len = e - s + 1 #渐变的长度
    #设置采样的总帧数
    if gradual_len < 2:
        continue    #跳过该渐变
    elif gradual_len == 2:
        total_sample = 2
    elif gradual_len == 3:
        total_sample = 3
    elif gradual_len < 3+ m:
        total_sample = gradual_len
    else:
        total_sample = 3 + m
     
    has_sampled=[]
    has_sampled.append(s)
    has_sampled.append(e)
    mid = (s + e) / 2
    if total_sample >= 3:
        has_sampled.append(mid)
    if total_sample > 3:
        remain = total_sample - 3
        for i in range(s+1,e):
            if i != mid:
                prob[i-s] = 1.0 / (gradual_len - 3)
        for frame in random.choice(x,size=remain,p=prob,replace=False):
            has_sampled.append(frame)
        
'''
从区间[s,e]中随机抽样k帧
'''